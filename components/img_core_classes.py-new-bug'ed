#this belongs in components/img_core_classes.py - Version: 9
# X-Seti - August07 2025 - IMG Factory 1.5 - Clean IMG Core Classes - FIXED STRUCTURE

"""
IMG Core Classes - CLEAN VERSION with 100% PRESERVED FUNCTIONALITY
Fixes import corruption by integrating properly with core/rebuild.py
ONLY changes: Fixed add_entry() corruption + proper rebuild integration
ALL other functionality preserved exactly as original
"""

import os
import struct
import json
import shutil
from enum import Enum
from typing import List, Dict, Optional, Any, Union, BinaryIO
from pathlib import Path
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QComboBox, QLineEdit, QGroupBox, QLabel)
from PyQt6.QtCore import pyqtSignal, Qt

# Import existing RW version functions - KEPT ALL ORIGINAL IMPORTS
from core.rw_versions import get_rw_version_name, parse_rw_version, get_model_format_version
from components.img_debug_functions import img_debugger

##Methods list -
# create_entries_table_panel
# create_img_file
# detect_img_platform
# detect_img_platform_inline
# detect_img_version
# format_file_size
# get_img_platform_info
# get_platform_specific_specs
# integrate_filtering
# populate_table_with_sample_data

##Classes -
# CompressionType
# FileType
# FilterPanel
# IMGEntriesTable
# IMGEntry
# IMGFile
# IMGFileInfoPanel
# IMGPlatform
# IMGVersion
# Platform
# RecentFilesManager
# TabFilterWidget
# ValidationResult

class IMGVersion(Enum):
    """IMG Archive Version Types"""
    VERSION_1 = 1    # DIR/IMG pair (GTA3, VC)
    VERSION_2 = 2    # Single IMG file (SA)
    UNKNOWN = 0

class IMGPlatform(Enum):
    """Platform types for IMG files"""
    PC = "pc"
    PS2 = "ps2" 
    XBOX = "xbox"
    ANDROID = "android"
    PSP = "psp"
    IOS = "ios"
    UNKNOWN = "unknown"

#class Platform(Enum): PC = "pc" XBOX = "xbox" PS2 = "ps2" <old
class Platform(Enum):
    """Platform types for IMG files"""
    PC = 0
    XBOX = 1
    PS2 = 2
    MOBILE = 3

class FileType(Enum):
    """File types found in IMG archives"""
    DFF = "dff"        # 3D models
    TXD = "txd"        # Texture dictionaries
    COL = "col"        # Collision files
    IFP = "ifp"        # Animation files
    IPL = "ipl"        # Item placement files
    DAT = "dat"        # Data files
    WAV = "wav"        # Audio files
    SCM = "scm"        # Script files
    UNKNOWN = "unknown"

class CompressionType(Enum):
    """Compression types for IMG entries"""
    NONE = 0
    ZLIB = 1
    LZ4 = 2
    CUSTOM = 99

class ValidationResult:
    """Result of IMG validation"""
    
    def __init__(self):
        self.is_valid: bool = True
        self.errors: List[str] = []
        self.warnings: List[str] = []
    
    def add_error(self, message: str): #vers 1
        self.errors.append(message)
        self.is_valid = False
    
    def add_warning(self, message: str): #vers 1
        self.warnings.append(message)

# INLINE PLATFORM DETECTION FUNCTIONS - PRESERVED TO AVOID CIRCULAR IMPORTS
def detect_img_platform(file_path: str): #vers 1
    """PRESERVED: Platform detection to avoid circular import"""
    try:
        filename = os.path.basename(file_path).lower()
        
        # Simple platform detection based on filename/path
        if any(keyword in filename for keyword in ['ps2', 'playstation']):
            return IMGPlatform.PS2, {'confidence': 70, 'indicators': ['ps2_filename']}
        elif any(keyword in filename for keyword in ['xbox']):
            return IMGPlatform.XBOX, {'confidence': 70, 'indicators': ['xbox_filename']}
        elif any(keyword in filename for keyword in ['android', 'mobile']):
            return IMGPlatform.ANDROID, {'confidence': 70, 'indicators': ['android_filename']}
        elif any(keyword in filename for keyword in ['psp', 'stories']):
            return IMGPlatform.PSP, {'confidence': 70, 'indicators': ['psp_filename']}
        else:
            return IMGPlatform.PC, {'confidence': 50, 'indicators': ['default_pc']}
            
    except Exception:
        return IMGPlatform.UNKNOWN, {'confidence': 0, 'indicators': ['error']}

def detect_img_platform_inline(file_path: str) -> IMGPlatform: #vers 1
    """PRESERVED: Simple platform detection to avoid circular import"""
    try:
        filename = os.path.basename(file_path).lower()

        if any(keyword in filename for keyword in ['ps2', 'playstation']):
            return IMGPlatform.PS2
        elif any(keyword in filename for keyword in ['xbox']):
            return IMGPlatform.XBOX
        elif any(keyword in filename for keyword in ['android', 'mobile']):
            return IMGPlatform.ANDROID
        elif any(keyword in filename for keyword in ['psp', 'stories']):
            return IMGPlatform.PSP
        else:
            return IMGPlatform.PC

    except Exception:
        return IMGPlatform.UNKNOWN

def get_platform_specific_specs(platform: IMGPlatform) -> Dict[str, Any]: #vers 1
    """PRESERVED: Get platform-specific specifications"""
    specs = {
        IMGPlatform.PC: {
            'sector_size': 2048,
            'entry_size': 32,
            'name_length': 24,
            'endianness': 'little',
            'supports_compression': True,
            'max_entries': 65535
        },
        IMGPlatform.PS2: {
            'sector_size': 2048,
            'entry_size': 32,
            'name_length': 24,
            'endianness': 'little',
            'supports_compression': False,
            'max_entries': 16000,
            'special_alignment': True
        },
        IMGPlatform.ANDROID: {
            'sector_size': 2048,
            'entry_size': 32,
            'name_length': 24,
            'endianness': 'little',
            'supports_compression': True,
            'max_entries': 32000,
            'mobile_optimized': True
        },
        IMGPlatform.PSP: {
            'sector_size': 2048,
            'entry_size': 32,
            'name_length': 24,
            'endianness': 'little',
            'supports_compression': False,
            'max_entries': 8000,
            'stories_format': True
        }
    }
    return specs.get(platform, specs[IMGPlatform.PC])

def get_img_platform_info(file_path: str) -> Dict[str, Any]: #vers 1
    """PRESERVED: Get platform information for IMG file"""
    platform, detection_info = detect_img_platform(file_path)
    return {
        'platform': platform.value,
        'detected_from': 'filename_analysis',
        'supported_features': {
            'compression': platform in [IMGPlatform.PC, IMGPlatform.ANDROID],
            'encryption': False,
            'large_files': platform != IMGPlatform.PSP
        }
    }

class IMGEntry:
    """Represents a single file entry within an IMG archive"""
    
    def __init__(self): #vers 4
        self.name: str = ""
        self.extension: str = ""
        self.offset: int = 0          
        self.size: int = 0            
        self.uncompressed_size: int = 0
        self.file_type: FileType = FileType.UNKNOWN
        self.compression_type: CompressionType = CompressionType.NONE
        self.rw_version: int = 0      
        self.rw_version_name: str = "Unknown" 
        self.is_encrypted: bool = False
        self.is_new_entry: bool = False
        self.is_replaced: bool = False
        self.flags: int = 0
        self.compression_level = 0

        # Internal data cache
        self._cached_data: Optional[bytes] = None
        self._img_file: Optional['IMGFile'] = None
        self._version_detected: bool = False
    
    def set_img_file(self, img_file: 'IMGFile'): #vers 1
        """Set reference to parent IMG file"""
        self._img_file = img_file

    def detect_file_type_and_version(self): #vers 3
        """Detect file type and RW version from file data"""
        try:
            # Extract extension from name
            if '.' in self.name:
                self.extension = self.name.split('.')[-1].upper()
                self.extension = ''.join(c for c in self.extension if c.isalpha())
            else:
                self.extension = "NO_EXT"
            
            # Set file type based on extension
            ext_lower = self.extension.lower()
            if ext_lower == 'dff':
                self.file_type = FileType.DFF
            elif ext_lower == 'txd':
                self.file_type = FileType.TXD
            elif ext_lower == 'col':
                self.file_type = FileType.COL
            elif ext_lower == 'ifp':
                self.file_type = FileType.IFP
            elif ext_lower == 'ipl':
                self.file_type = FileType.IPL
            elif ext_lower == 'dat':
                self.file_type = FileType.DAT
            elif ext_lower == 'wav':
                self.file_type = FileType.WAV
            else:
                self.file_type = FileType.UNKNOWN

            # Detect RW version for RenderWare files
            if self.extension in ['DFF', 'TXD'] and not self._version_detected:
                self._detect_rw_version()
                
        except Exception as e:
            img_debugger.error(f"Error detecting file type for {self.name}: {e}")

    def _detect_rw_version(self): #vers 1
        """Detect RenderWare version from file header"""
        try:
            if not self._img_file or not self._img_file.file_path:
                return

            # Read file header (first 12 bytes contain RW version info)
            file_data = self._read_header_data(12)
            if not file_data or len(file_data) < 12:
                return

            # Use existing parse_rw_version function
            version_value, version_name = parse_rw_version(file_data[8:12])
            
            if version_value > 0:
                self.rw_version = version_value
                self.rw_version_name = version_name
                self._version_detected = True
                
                img_debugger.debug(f"✅ RW Version detected for {self.name}: {version_name}")
            else:
                self.rw_version_name = "Unknown"
                
        except Exception as e:
            img_debugger.debug(f"RW version detection failed for {self.name}: {e}")

    def _read_header_data(self, header_size: int = 12) -> Optional[bytes]: #vers 1
        """Read header data from entry using IMG file"""
        try:
            if not self._img_file or not self._img_file.file_path:
                return None
            
            # Determine file path based on IMG version
            if self._img_file.version == IMGVersion.VERSION_1:
                img_path = self._img_file.file_path.replace('.dir', '.img')
            else:
                img_path = self._img_file.file_path
            
            # Read header data
            with open(img_path, 'rb') as f:
                f.seek(self.offset)
                return f.read(min(header_size, self.size))
                
        except Exception as e:
            return None

    def get_version_text(self) -> str: #vers 2
        """FIXED: Get human-readable version text"""
        try:
            if self.extension in ['DFF', 'TXD']:
                if self.rw_version > 0 and self.rw_version_name:
                    return f"RW {self.rw_version_name}"
                elif self.rw_version > 0:
                    return f"RW 0x{self.rw_version:X}"
                else:
                    return "RW Unknown"
            elif self.extension == 'COL':
                return "COL"
            elif self.extension == 'IFP':
                return "IFP"
            elif self.extension == 'IPL':
                return "IPL"
            elif self.extension in ['WAV', 'MP3']:
                return "Audio"
            else:
                return "Unknown"
        except:
            return "Unknown"

    def get_offset_in_sectors(self) -> int: #vers 1
        """Get offset in 2048-byte sectors"""
        return self.offset // 2048

    def get_size_in_sectors(self) -> int: #vers 1
        """Get size in 2048-byte sectors (rounded up)"""
        return (self.size + 2047) // 2048

    def _get_file_type_from_extension(self) -> FileType: #vers 1
        """Get file type from extension"""
        ext_lower = self.extension.lower()
        try:
            return FileType(ext_lower)
        except ValueError:
            return FileType.UNKNOWN
    
    def is_renderware_file(self) -> bool: #vers 1
        """Check if file is a RenderWare format"""
        return self.extension.upper() in ['DFF', 'TXD']
    
    def validate(self) -> ValidationResult: #vers 1
        """Validate entry data"""
        result = ValidationResult()
        
        try:
            # Check basic attributes
            if not self.name:
                result.add_error("Entry has no name")
            
            if self.size < 0:
                result.add_error("Entry has negative size")
            
            if self.offset < 0:
                result.add_error("Entry has negative offset")
            
            # Check name validity
            if len(self.name) > 24:
                result.add_warning("Entry name longer than 24 characters")
            
            invalid_chars = set('\x00\xff\xcd')
            if any(char in self.name for char in invalid_chars):
                result.add_error("Entry name contains invalid characters")
            
            # Validate data if available
            if self._img_file:
                try:
                    data = self.get_data()
                    if len(data) != self.size:
                        result.add_warning(f"Entry {self.name} actual size differs from header")
                except Exception as e:
                    result.add_error(f"Cannot read data for {self.name}: {str(e)}")

        except Exception as e:
            result.add_error(f"Validation error for {self.name}: {str(e)}")

        return result
    
    def get_data(self) -> bytes: #vers 1
        """Get entry data - uses cache if available"""
        try:
            # Return cached data if available
            if self._cached_data is not None:
                return self._cached_data
            
            # Read data from file
            if not self._img_file:
                return b''
                
            return self._img_file.read_entry_data(self)
            
        except Exception as e:
            img_debugger.error(f"Failed to get data for {self.name}: {e}")
            return b''
    

    def set_data(self, data: bytes): #vers 1
        """Write entry data to IMG file"""
        self._cached_data = data
        self.size = len(data)
        if not self._img_file:
            raise ValueError("No IMG file reference set")

        self._img_file.write_entry_data(self, data)

class IMGFile:
    """Main IMG archive file handler with FIXED CORRUPTION"""
    
    def __init__(self, file_path: str = ""): #vers 5
        self.file_path: str = file_path
        self.version: IMGVersion = IMGVersion.UNKNOWN
        self.platform: IMGPlatform = IMGPlatform.UNKNOWN
        self.platform_specs: Dict[str, Any] = {}
        self.entries: List[IMGEntry] = []
        self.is_open: bool = False
        self.total_size: int = 0
        self.creation_time: Optional[float] = None
        self.modification_time: Optional[float] = None

        # File handles
        self._img_handle: Optional[BinaryIO] = None
        self._dir_handle: Optional[BinaryIO] = None


    def create_new(self, output_path: str, version: IMGVersion, **options) -> bool: #vers 2
        """Create new IMG file with specified parameters"""
        try:
            self.file_path = output_path
            self.version = version
            self.entries = []

            # Extract creation options
            initial_size_mb = options.get('initial_size_mb', 50)
            compression_enabled = options.get('compression_enabled', False)
            game_preset = options.get('game_preset', None)

            if version == IMGVersion.VERSION_1:
                # Use Version 1 creator
                from core.img_version1 import IMGVersion1Creator
                creator = IMGVersion1Creator()
                success = creator.create_version_1(output_path, initial_size_mb)
                if success:
                    self.entries = creator.entries
                    self.file_path = creator.dir_path  # Store DIR file path for Version 1
                return success

            elif version == IMGVersion.VERSION_2:
                # Use Version 2 creator
                from core.img_version2 import IMGVersion2Creator
                creator = IMGVersion2Creator()
                success = creator.create_version_2(output_path, initial_size_mb, compression_enabled)
                if success:
                    self.entries = creator.entries
                    self.file_path = creator.file_path
                return success

            else:
                print(f"❌ Unsupported IMG version: {version}")
                return False

        except Exception as e:
            print(f"❌ Error creating IMG file: {e}")
            return False


    def detect_version(self) -> IMGVersion: #vers 4
        """Detect IMG version and platform from file"""
        try:
            if not os.path.exists(self.file_path):
                return IMGVersion.UNKNOWN

            # Platform detection first
            detected_platform, detection_info = detect_img_platform(self.file_path)
            self.platform = detected_platform
            self.platform_specs = get_platform_specific_specs(detected_platform)
            
            print(f"[DEBUG] Detected platform: {detected_platform.value}")
            print(f"[DEBUG] Platform specs: {self.platform_specs}")

            # Check if it's a .dir file (Version 1)
            if self.file_path.lower().endswith('.dir'):
                img_path = self.file_path[:-4] + '.img'
                if os.path.exists(img_path):
                    self.version = IMGVersion.VERSION_1
                    return IMGVersion.VERSION_1

            # Check if it's a single .img file (Version 2)
            if self.file_path.lower().endswith('.img'):
                try:
                    with open(self.file_path, 'rb') as f:
                        header = f.read(4)
                        if header == b'VER2':
                            self.version = IMGVersion.VERSION_2
                            return IMGVersion.VERSION_2
                        # Could be Version 1 IMG file without DIR
                        self.version = IMGVersion.VERSION_1
                        return IMGVersion.VERSION_1
                except:
                    pass

        except Exception as e:
            print(f"[ERROR] Error detecting IMG version: {e}")

        self.version = IMGVersion.UNKNOWN
        return IMGVersion.UNKNOWN

    def open(self) -> bool: #vers 5
        """Open and parse IMG file"""
        try:
            if self.is_open:
                return True

            # Detect version first
            if self.version == IMGVersion.UNKNOWN:
                self.version = self.detect_version()

            if self.version == IMGVersion.VERSION_1:
                return self._load_version1()
            elif self.version == IMGVersion.VERSION_2:
                return self._load_version2()
            else:
                print(f"[ERROR] Unknown IMG version")
                return False

        except Exception as e:
            print(f"[ERROR] Failed to open IMG file: {e}")
            return False

    def _parse_all_entries(self): #vers 2
        """ADDED: Parse file types and versions for all entries + UNKNOWN RW DETECTION"""
        try:
            print(f"[DEBUG] Parsing {len(self.entries)} entries for file types and versions")

            for i, entry in enumerate(self.entries):
                try:
                    # Detect file type and RW version
                    entry.detect_file_type_and_version()

                    # Log progress for large files
                    if i > 0 and i % 100 == 0:
                        print(f"[DEBUG] Parsed {i}/{len(self.entries)} entries")

                except Exception as e:
                    print(f"[WARNING] Error parsing entry {entry.name}: {e}")

            print(f"[SUCCESS] Completed parsing all entries")

            # ADDED: Trigger unknown RW file detection after parsing
            self._trigger_unknown_rw_detection()

        except Exception as e:
            print(f"[ERROR] Error in _parse_all_entries: {e}")


    def _trigger_unknown_rw_detection(self): #vers 1
        """ADDED: Trigger unknown RW file detection and snapshotting"""
        try:
            # Try to find main window reference for unknown RW detection
            # This will be set by the integration function
            if hasattr(self, '_main_window_ref') and self._main_window_ref:
                main_window = self._main_window_ref
                if hasattr(main_window, 'rw_snapshot_manager'):
                    unknown_files = main_window.rw_snapshot_manager.capture_unknown_rw_files(self)
                    if unknown_files:
                        print(f"[INFO] Captured {len(unknown_files)} unknown RW files for analysis")
                else:
                    print(f"[DEBUG] RW snapshot manager not available - skipping unknown detection")
            else:
                print(f"[DEBUG] Main window reference not available - skipping unknown detection")

        except Exception as e:
            print(f"[WARNING] Error in unknown RW detection: {e}")


    def set_main_window_reference(self, main_window): #vers 1
        """ADDED: Set main window reference for unknown RW detection"""
        self._main_window_ref = main_window


    def _open_version_2(self) -> bool: #vers 5
        """Open IMG version 2 (single file) - ENHANCED WITH PLATFORM SUPPORT"""
        try:
            # Use platform-specific specifications
            sector_size = self.platform_specs.get('sector_size', 2048)

            with open(self.file_path, 'rb') as f:
                # Skip VER2 header (4 bytes)
                f.seek(4)
                # Read entry count
                entry_count = struct.unpack('<I', f.read(4))[0]

                # Platform-specific entry count validation
                max_entries = self.platform_specs.get('max_entries', 65535)
                if entry_count > max_entries:
                    print(f"[WARNING] Entry count {entry_count} exceeds platform limit {max_entries}")

                for i in range(entry_count):
                    # Read entry: offset(4), size(4), name(24)
                    entry_data = f.read(32)
                    if len(entry_data) < 32:
                        break

                    entry_offset, entry_size = struct.unpack('<II', entry_data[:8])
                    entry_name = entry_data[8:32].rstrip(b'\x00').decode('ascii', errors='ignore')

                    if entry_name:
                        entry = IMGEntry()
                        entry.name = entry_name
                        entry.offset = entry_offset * 2048  # Convert sectors to bytes
                        entry.size = entry_size * 2048
                        entry.set_img_file(self)
                        self.entries.append(entry)

            return True
        except Exception as e:
            print(f"[ERROR] Error opening Version 2 IMG: {e}")
            return False

    def _open_version_1(self) -> bool: #vers 4
        """Open IMG version 1 (DIR/IMG pair)"""
        dir_path = self.file_path[:-4] + '.dir'
        if not os.path.exists(dir_path):
            return False

        try:
            with open(dir_path, 'rb') as dir_file:
                dir_data = dir_file.read()

            # Parse directory entries (32 bytes each)
            entry_count = len(dir_data) // 32
            for i in range(entry_count):
                offset = i * 32
                entry_data = dir_data[offset:offset+32]

                if len(entry_data) < 32:
                    break

                # Parse entry: offset(4), size(4), name(24)
                entry_offset, entry_size = struct.unpack('<II', entry_data[:8])
                entry_name = entry_data[8:32].rstrip(b'\x00').decode('ascii', errors='ignore')

                if entry_name:
                    entry = IMGEntry()
                    entry.name = entry_name
                    entry.offset = entry_offset * 2048  # Convert sectors to bytes
                    entry.size = entry_size * 2048
                    entry.set_img_file(self)
                    self.entries.append(entry)

            return True
        except Exception as e:
            print(f"[ERROR] Error opening Version 1 IMG: {e}")
            return False


    def _load_version2(self) -> bool: #vers 1
        """Load Version 2 IMG file (SA format)"""
        try:
            with open(self.file_path, 'rb') as f:
                # Read header to get entry count
                header = f.read(4)
                if header != b'VER2':
                    # Try to parse as directory-based format
                    f.seek(0)
                    dir_data = f.read()
                else:
                    # Skip VER2 header and read directory
                    dir_data = f.read()

                # Parse entries (32 bytes each)
                for i in range(len(dir_data) // 32):
                    offset = i * 32
                    entry_data = dir_data[offset:offset+32]

                    if len(entry_data) < 32:
                        break

                    # Parse entry: offset(4), size(4), name(24)
                    entry_offset, entry_size = struct.unpack('<II', entry_data[:8])
                    entry_name = entry_data[8:32].rstrip(b'\x00').decode('ascii', errors='ignore')

                    if entry_name:
                        entry = IMGEntry()
                        entry.name = entry_name
                        entry.offset = entry_offset
                        entry.size = entry_size
                        entry.set_img_file(self)
                        entry.detect_file_type_and_version()
                        self.entries.append(entry)

                self.is_open = True
                return True

        except Exception as e:
            print(f"[ERROR] Error loading Version 2 IMG: {e}")
            return False

    def _load_version1(self) -> bool: #vers 1
        """Load Version 1 IMG file (DIR/IMG pair)"""
        try:
            # Read DIR file
            with open(self.file_path, 'rb') as f:
                dir_data = f.read()

            # Parse entries (32 bytes each)
            for i in range(len(dir_data) // 32):
                offset = i * 32
                entry_data = dir_data[offset:offset+32]

                if len(entry_data) < 32:
                    break

                # Parse entry: offset(4), size(4), name(24)
                entry_offset, entry_size = struct.unpack('<II', entry_data[:8])
                entry_name = entry_data[8:32].rstrip(b'\x00').decode('ascii', errors='ignore')

                if entry_name:
                    entry = IMGEntry()
                    entry.name = entry_name
                    entry.offset = entry_offset * 2048  # Convert sectors to bytes
                    entry.size = entry_size * 2048
                    entry.set_img_file(self)
                    entry.detect_file_type_and_version()
                    self.entries.append(entry)

            self.is_open = True
            return True
            
        except Exception as e:
            print(f"[ERROR] Error loading Version 1 IMG: {e}")
            return False

    def read_entry_data(self, entry: IMGEntry) -> bytes: #vers 1
        """Read data for a specific entry"""
        try:
            if self.version == IMGVersion.VERSION_1:
                # Read from .img file
                img_path = self.file_path.replace('.dir', '.img')
                with open(img_path, 'rb') as f:
                    f.seek(entry.offset)
                    return f.read(entry.size)
            else:
                # Read from single .img file
                with open(self.file_path, 'rb') as f:
                    f.seek(entry.offset)
                    return f.read(entry.size)
        except Exception as e:
            raise RuntimeError(f"Failed to read entry data: {e}")

    def write_entry_data(self, entry: IMGEntry, data: bytes): #vers 1
        """Write data for a specific entry"""
        try:
            if self.version == IMGVersion.VERSION_1:
                # Write to .img file
                img_path = self.file_path.replace('.dir', '.img')
                with open(img_path, 'r+b') as f:
                    f.seek(entry.offset)
                    f.write(data)
            else:
                # Write to single .img file
                with open(self.file_path, 'r+b') as f:
                    f.seek(entry.offset)
                    f.write(data)
        except Exception as e:
            raise RuntimeError(f"Failed to write entry data: {e}")

    def add_entry(self, filename: str, data: bytes, auto_save: bool = True) -> bool: #vers 2
        """FIXED: Add new entry to IMG file - CORRUPTION FIX using core/rebuild.py"""
        try:
            print(f"[DEBUG] Adding entry: {filename} (current entries: {len(self.entries)})")

            # Check for duplicate entries (replace if exists)
            existing_entry = None
            for i, entry in enumerate(self.entries):
                if entry.name == filename:
                    existing_entry = entry
                    print(f"[DEBUG] Replacing existing entry: {filename}")
                    break

            # FIXED: Calculate proper offset for new entry
            if existing_entry:
                # Replace existing entry data
                new_entry = existing_entry
                new_entry._cached_data = data
                new_entry.size = len(data)
                # Keep existing offset for replacement
            else:
                # Create brand new entry
                new_entry = IMGEntry()
                new_entry.name = filename
                new_entry.size = len(data)
                new_entry.offset = self.calculate_next_offset()  # FIXED: Proper calculation
                new_entry.set_img_file(self)
                new_entry._cached_data = data

                # Detect file type and RW version from data
                new_entry.detect_file_type_and_version()

                # Add to entries list
                self.entries.append(new_entry)

            print(f"[DEBUG] Entry added: {filename} at offset 0x{new_entry.offset:08X}, size {new_entry.size} bytes")
            print(f"[DEBUG] Total entries now: {len(self.entries)}")

            # FIXED: Save using proper rebuild system from core/rebuild.py
            if auto_save:
                print(f"[DEBUG] Auto-saving using core/rebuild.py...")
                success = self._save_using_core_rebuild()
                if success:
                    print(f"[DEBUG] IMG file saved successfully")
                else:
                    print(f"[ERROR] Failed to save IMG file after adding {filename}")
                return success

            # Entry added successfully but not saved
            return True

        except Exception as e:
            print(f"[ERROR] Failed to add entry {filename}: {e}")
            return False

    def calculate_next_offset(self) -> int: #vers 1
        """FIXED: Calculate the next available offset for a new entry"""
        try:
            if not self.entries:
                # First entry
                if self.version == IMGVersion.VERSION_1:
                    return 0  # Version 1 starts at beginning of .img file
                else:
                    # Version 2: Start after directory
                    return 0  # Will be recalculated during rebuild

            # FIXED: Find the entry that ends the latest and align properly
            max_end = 0
            for entry in self.entries:
                entry_end = entry.offset + entry.size
                if entry_end > max_end:
                    max_end = entry_end

            # Align to sector boundary (2048 bytes)
            aligned_offset = ((max_end + 2047) // 2048) * 2048
            return aligned_offset

        except Exception as e:
            print(f"[ERROR] Failed to calculate next offset: {e}")
            return 0

    def _save_using_core_rebuild(self) -> bool: #vers 1
        """FIXED: Save IMG file using proper core/rebuild.py system"""
        try:
            # Import the proper rebuild function from core/rebuild.py
            from core.rebuild import _rebuild_single_file_sync
            
            # Create rebuild options
            rebuild_options = {
                'create_backup': True,
                'optimize_structure': True
            }
            
            # Use the core rebuild system (this is the working one)
            return _rebuild_single_file_sync(self, rebuild_options)
            
        except ImportError:
            # Fallback to save_img_entry.py if core/rebuild.py not available
            print("[WARNING] core/rebuild.py not available, using fallback save method")
            return self._fallback_save()
            
        except Exception as e:
            print(f"[ERROR] Core rebuild save failed: {e}")
            return False

    def _fallback_save(self) -> bool: #vers 1
        """Fallback save method using save_img_entry.py"""
        try:
            from core.save_img_entry import save_img_file_with_backup
            return save_img_file_with_backup(self)
        except Exception as e:
            print(f"[ERROR] Fallback save failed: {e}")
            return False

    def remove_entry(self, filename: str) -> bool: #vers 1
        """Remove entry by filename"""
        try:
            for i, entry in enumerate(self.entries):
                if entry.name == filename:
                    removed_entry = self.entries.pop(i)
                    print(f"[DEBUG] Removed entry: {filename}")
                    return True

            print(f"[WARNING] Entry not found for removal: {filename}")
            return False

        except Exception as e:
            print(f"[ERROR] Failed to remove entry {filename}: {e}")
            return False

    def has_entry(self, filename: str) -> bool: #vers 1
        """Check if entry exists by filename"""
        try:
            return any(entry.name == filename for entry in self.entries)
        except Exception:
            return False

    def get_entry(self, filename: str) -> Optional[IMGEntry]: #vers 1
        """Get entry by filename"""
        try:
            for entry in self.entries:
                if entry.name == filename:
                    return entry
            return None
        except Exception:
            return None

    def find_entry(self, filename: str) -> Optional[IMGEntry]: #vers 1
        """Find entry by filename - alias for get_entry"""
        return self.get_entry(filename)

    def add_multiple_entries(self, file_data_pairs: List[tuple], auto_save: bool = True) -> int: #vers 1
        """Add multiple entries efficiently - BATCH METHOD"""
        try:
            added_count = 0

            print(f"[DEBUG] Adding {len(file_data_pairs)} entries in batch mode...")

            for filename, data in file_data_pairs:
                # Add without auto-save for efficiency
                if self.add_entry(filename, data, auto_save=False):
                    added_count += 1
                else:
                    print(f"[WARNING] Failed to add {filename} in batch")

            # FIXED: Save once at the end using core/rebuild.py
            if auto_save and added_count > 0:
                print(f"[DEBUG] Batch save: {added_count} entries added")
                if self._save_using_core_rebuild():
                    print(f"[DEBUG] Batch save successful")
                else:
                    print(f"[ERROR] Batch save failed")
                    return 0

            print(f"[SUCCESS] Batch add complete: {added_count}/{len(file_data_pairs)} entries added")
            return added_count

        except Exception as e:
            print(f"[ERROR] Batch add failed: {e}")
            return 0


    def close(self) -> bool: #vers 1
        """Close IMG file"""
        self.is_open = False
        self.entries.clear()
        return True

    def get_creation_info(self) -> Dict[str, Any]: #vers 1
        """Get information about the IMG file"""
        if not self.file_path or not os.path.exists(self.file_path):
            return {}
        
        try:
            file_size = os.path.getsize(self.file_path)
            return {
                'file_path': self.file_path,
                'file_size': file_size,
                'file_size_mb': file_size / (1024 * 1024),
                'entry_count': len(self.entries),
                'version': self.version.value if self.version != IMGVersion.UNKNOWN else 'Unknown',
                'platform': self.platform.value if self.platform != IMGPlatform.UNKNOWN else 'Unknown'
            }
        except Exception:
            return {}

    def save_img_file(self) -> bool: #vers 1
        """Save IMG file with current entries - COMPATIBILITY METHOD"""
        return self._save_using_core_rebuild()

    def rebuild_img_file(self) -> bool: #vers 1
        """Rebuild IMG file with current entries - COMPATIBILITY METHOD"""
        return self._save_using_core_rebuild()


    def _rebuild_version2(self) -> bool: #vers 1
        """Rebuild Version 2 IMG file (SA format)"""
        try:
            import struct
            import os

            # Calculate sizes
            entry_count = len(self.entries)
            directory_size = entry_count * 32  # 32 bytes per entry
            data_start = directory_size

            # Collect entry data
            entry_data_list = []
            current_offset = data_start

            for entry in self.entries:
                # Get entry data
                if hasattr(entry, '_cached_data') and entry._cached_data:
                    data = entry._cached_data
                else:
                    data = self.read_entry_data(entry)

                entry_data_list.append(data)

                # Update entry with new offset/size
                entry.offset = current_offset
                entry.size = len(data)

                # Align to sector boundary (2048 bytes)
                aligned_size = ((len(data) + 2047) // 2048) * 2048
                current_offset += aligned_size

            # Write new IMG file
            with open(self.file_path, 'wb') as f:
                # Write directory
                for i, entry in enumerate(self.entries):
                    # Convert to sectors
                    offset_sectors = entry.offset // 2048
                    size_sectors = ((entry.size + 2047) // 2048)

                    # Pack entry: offset(4), size(4), name(24)
                    entry_data = struct.pack('<II', offset_sectors, size_sectors)
                    name_bytes = entry.name.encode('ascii')[:24].ljust(24, b'\x00')
                    entry_data += name_bytes

                    f.write(entry_data)

                # Write file data
                for i, data in enumerate(entry_data_list):
                    f.seek(self.entries[i].offset)
                    f.write(data)

                    # Pad to sector boundary
                    current_pos = f.tell()
                    sector_end = ((current_pos + 2047) // 2048) * 2048
                    if current_pos < sector_end:
                        f.write(b'\x00' * (sector_end - current_pos))

            print(f"✅ Rebuilt IMG file: {entry_count} entries")
            return True

        except Exception as e:
            print(f"[ERROR] Failed to rebuild Version 2 IMG: {e}")
            return False

    def _rebuild_version1(self) -> bool: #vers 1
        """Rebuild Version 1 IMG file (DIR/IMG pair)"""
        try:
            import struct
            import os

            # Get DIR and IMG paths
            dir_path = self.file_path
            img_path = self.file_path.replace('.dir', '.img')

            entry_count = len(self.entries)

            # Collect entry data and calculate offsets
            entry_data_list = []
            current_offset = 0

            for entry in self.entries:
                # Get entry data
                if hasattr(entry, '_cached_data') and entry._cached_data:
                    data = entry._cached_data
                else:
                    data = self.read_entry_data(entry)

                entry_data_list.append(data)

                # Update entry with new offset/size
                entry.offset = current_offset
                entry.size = len(data)

                # Align to sector boundary
                aligned_size = ((len(data) + 2047) // 2048) * 2048
                current_offset += aligned_size

            # Write DIR file
            with open(dir_path, 'wb') as f:
                for entry in self.entries:
                    # Convert to sectors
                    offset_sectors = entry.offset // 2048
                    size_sectors = ((entry.size + 2047) // 2048)

                    # Pack entry: offset(4), size(4), name(24)
                    entry_data = struct.pack('<II', offset_sectors, size_sectors)
                    name_bytes = entry.name.encode('ascii')[:24].ljust(24, b'\x00')
                    entry_data += name_bytes

                    f.write(entry_data)

            # Write IMG file
            with open(img_path, 'wb') as f:
                for i, data in enumerate(entry_data_list):
                    f.seek(self.entries[i].offset)
                    f.write(data)

                    # Pad to sector boundary
                    current_pos = f.tell()
                    sector_end = ((current_pos + 2047) // 2048) * 2048
                    if current_pos < sector_end:
                        f.write(b'\x00' * (sector_end - current_pos))

            print(f"✅ Rebuilt DIR/IMG pair: {entry_count} entries")
            return True

        except Exception as e:
            print(f"[ERROR] Failed to rebuild Version 1 IMG: {e}")
            return False


    def import_file(self, file_path: str) -> bool: #vers 1
        """Import file into IMG - uses add_entry"""
        try:
            filename = os.path.basename(file_path)

            # Read file data
            with open(file_path, 'rb') as f:
                data = f.read()

            # Use add_entry method
            return self.add_entry(filename, data)

        except Exception as e:
            print(f"[ERROR] Failed to import file {file_path}: {e}")
            return False


#    def _rebuild_version2(self) -> bool: #vers 1
#        """REMOVED: Conflicting rebuild method - use core/rebuild.py instead"""
#        print("[WARNING] _rebuild_version2 removed - use core/rebuild.py system")
#        return self._save_using_core_rebuild()

#    def _rebuild_version1(self) -> bool: #vers 1
#        """REMOVED: Conflicting rebuild method - use core/rebuild.py instead"""
#        print("[WARNING] _rebuild_version1 removed - use core/rebuild.py system")
#        return self._save_using_core_rebuild()

# COMPLETE GUI CLASSES FOR FULL COMPATIBILITY

class IMGEntriesTable(QTableWidget):
    """Table widget for displaying IMG entries with sorting and filtering"""
    
    entry_selected = pyqtSignal(object)
    entries_selected = pyqtSignal(list)
    
    def __init__(self, parent=None): #vers 1
        super().__init__(parent)
        self.setup_table()
        self.entries = []
        self.filtered_entries = []
        self.sort_column = 0
        self.sort_order = Qt.SortOrder.AscendingOrder
    
    def setup_table(self): #vers 1
        """Setup table headers and properties"""
        headers = ["Name", "Type", "Size", "Offset", "RW Version", "RW Hex", "Info"]
        self.setColumnCount(len(headers))
        self.setHorizontalHeaderLabels(headers)
        
        # Configure table
        self.setAlternatingRowColors(True)
        self.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.setSortingEnabled(True)
        
        # Set column widths - UPDATED with RW Hex column
        header = self.horizontalHeader()
        header.resizeSection(0, 200)  # Name
        header.resizeSection(1, 80)   # Type
        header.resizeSection(2, 100)  # Size
        header.resizeSection(3, 100)  # Offset
        header.resizeSection(4, 120)  # RW Version
        header.resizeSection(5, 100)  # RW Hex - NEW COLUMN
        header.resizeSection(6, 150)  # Info
        
        # Connect selection signal
        self.itemSelectionChanged.connect(self._on_selection_changed)

    def _on_selection_changed(self): #vers 1
        """Handle selection change"""
        selected_rows = list(set(item.row() for item in self.selectedItems()))
        if len(selected_rows) == 1:
            entry = self.entries[selected_rows[0]] if selected_rows[0] < len(self.entries) else None
            if entry:
                self.entry_selected.emit(entry)
        elif selected_rows:
            selected_entries = [self.entries[row] for row in selected_rows if row < len(self.entries)]
            self.entries_selected.emit(selected_entries)

    def populate_entries(self, entries: List[IMGEntry]): #vers 1
        """Populate table with IMG entries"""
        self.entries = entries
        self.setRowCount(len(entries))
        
        for row, entry in enumerate(entries):
            # Name
            name_item = QTableWidgetItem(entry.name)
            self.setItem(row, 0, name_item)
            
            # Type
            type_item = QTableWidgetItem(entry.extension)
            self.setItem(row, 1, type_item)
            
            # Size
            size_item = QTableWidgetItem(format_file_size(entry.size))
            self.setItem(row, 2, size_item)
            
            # Offset
            offset_item = QTableWidgetItem(f"0x{entry.offset:08X}")
            self.setItem(row, 3, offset_item)
            
            # RW Version
            rw_version_item = QTableWidgetItem(entry.rw_version_name)
            self.setItem(row, 4, rw_version_item)
            
            # RW Hex - NEW COLUMN with proper hex formatting
            if entry.rw_version > 0:
                rw_hex_item = QTableWidgetItem(f"0x{entry.rw_version:08X}")
            else:
                rw_hex_item = QTableWidgetItem("N/A")
            self.setItem(row, 5, rw_hex_item)
            
            # Info
            info_text = f"{entry.file_type.value.upper()}" if entry.file_type != FileType.UNKNOWN else "Unknown"
            if entry.is_new_entry:
                info_text += " (New)"
            if entry.is_replaced:
                info_text += " (Replaced)"
            info_item = QTableWidgetItem(info_text)
            self.setItem(row, 6, info_item)

class FilterPanel(QWidget):
    """Filter panel for IMG entries"""
    
    filter_changed = pyqtSignal(dict)
    
    def __init__(self, parent=None): #vers 1
        super().__init__(parent)
        self.setup_ui()
        self.current_filters = {}
    
    def setup_ui(self): #vers 1
        """Setup filter UI"""
        layout = QHBoxLayout(self)
        
        # File type filter
        self.type_combo = QComboBox()
        self.type_combo.addItems(["All Types", "DFF", "TXD", "COL", "IFP", "IPL", "DAT", "WAV", "Other"])
        self.type_combo.currentTextChanged.connect(self._on_type_filter_changed)
        layout.addWidget(QLabel("Type:"))
        layout.addWidget(self.type_combo)
        
        # Name filter
        self.name_edit = QLineEdit()
        self.name_edit.setPlaceholderText("Filter by name...")
        self.name_edit.textChanged.connect(self._on_name_filter_changed)
        layout.addWidget(QLabel("Name:"))
        layout.addWidget(self.name_edit)
        
        # RW Version filter
        self.rw_combo = QComboBox()
        self.rw_combo.addItems(["All Versions", "3.1.0.1", "3.6.0.3", "3.4.0.3", "Unknown", "N/A"])
        self.rw_combo.currentTextChanged.connect(self._on_rw_filter_changed)
        layout.addWidget(QLabel("RW Version:"))
        layout.addWidget(self.rw_combo)

    def _on_type_filter_changed(self, text: str): #vers 1
        """Handle type filter change"""
        self.current_filters['type'] = text if text != "All Types" else None
        self.filter_changed.emit(self.current_filters)

    def _on_name_filter_changed(self, text: str): #vers 1
        """Handle name filter change"""
        self.current_filters['name'] = text.lower() if text else None
        self.filter_changed.emit(self.current_filters)

    def _on_rw_filter_changed(self, text: str): #vers 1
        """Handle RW version filter change"""
        self.current_filters['rw_version'] = text if text != "All Versions" else None
        self.filter_changed.emit(self.current_filters)

class IMGFileInfoPanel(QWidget):
    """Info panel showing IMG file statistics"""
    
    def __init__(self, parent=None): #vers 1
        super().__init__(parent)
        self.setup_ui()
        self.current_img = None
    
    def setup_ui(self): #vers 1
        """Setup info panel UI"""
        layout = QVBoxLayout(self)
        
        # File info group
        file_group = QGroupBox("File Info")
        file_layout = QVBoxLayout(file_group)
        
        self.file_label = QLabel("No IMG file loaded")
        self.size_label = QLabel("Size: N/A")
        self.version_label = QLabel("Version: N/A")
        self.platform_label = QLabel("Platform: N/A")
        
        file_layout.addWidget(self.file_label)
        file_layout.addWidget(self.size_label)
        file_layout.addWidget(self.version_label)
        file_layout.addWidget(self.platform_label)
        
        # Entries info group
        entries_group = QGroupBox("Entries Info")
        entries_layout = QVBoxLayout(entries_group)
        
        self.entries_label = QLabel("Entries: 0")
        self.types_label = QLabel("File Types: N/A")
        self.rw_versions_label = QLabel("RW Versions: N/A")
        
        entries_layout.addWidget(self.entries_label)
        entries_layout.addWidget(self.types_label)
        entries_layout.addWidget(self.rw_versions_label)
        
        layout.addWidget(file_group)
        layout.addWidget(entries_group)

    def update_info(self, img_file: IMGFile): #vers 1
        """Update info panel with IMG file data"""
        self.current_img = img_file
        
        if img_file and img_file.file_path:
            # File info
            self.file_label.setText(f"File: {os.path.basename(img_file.file_path)}")
            
            creation_info = img_file.get_creation_info()
            if creation_info:
                self.size_label.setText(f"Size: {creation_info.get('file_size_mb', 0):.1f} MB")
                self.version_label.setText(f"Version: {creation_info.get('version', 'Unknown')}")
                self.platform_label.setText(f"Platform: {creation_info.get('platform', 'Unknown')}")
            
            # Entries info
            entry_count = len(img_file.entries)
            self.entries_label.setText(f"Entries: {entry_count}")
            
            # Analyze file types
            if img_file.entries:
                type_counts = {}
                rw_versions = set()
                
                for entry in img_file.entries:
                    file_type = entry.extension if entry.extension else "Unknown"
                    type_counts[file_type] = type_counts.get(file_type, 0) + 1
                    
                    if entry.rw_version_name and entry.rw_version_name != "Unknown":
                        rw_versions.add(entry.rw_version_name)
                
                # Format types info
                top_types = sorted(type_counts.items(), key=lambda x: x[1], reverse=True)[:3]
                types_text = ", ".join([f"{t}: {c}" for t, c in top_types])
                self.types_label.setText(f"Types: {types_text}")
                
                # Format RW versions info
                if rw_versions:
                    rw_text = ", ".join(sorted(rw_versions))
                    self.rw_versions_label.setText(f"RW Versions: {rw_text}")
                else:
                    self.rw_versions_label.setText("RW Versions: None detected")
            
        else:
            # Clear info
            self.file_label.setText("No IMG file loaded")
            self.size_label.setText("Size: N/A")
            self.version_label.setText("Version: N/A")
            self.platform_label.setText("Platform: N/A")
            self.entries_label.setText("Entries: 0")
            self.types_label.setText("File Types: N/A")
            self.rw_versions_label.setText("RW Versions: N/A")

class TabFilterWidget(QWidget):
    """Tab-based filter widget"""
    
    def __init__(self, parent=None): #vers 1
        super().__init__(parent)
        self.setup_ui()
    
    def setup_ui(self): #vers 1
        """Setup tab filter UI"""
        layout = QVBoxLayout(self)
        # Tab implementation would go here - placeholder for now
        self.info_label = QLabel("Tab Filter Widget - Not implemented")
        layout.addWidget(self.info_label)

class RecentFilesManager:
    """Manager for recent files list"""
    
    def __init__(self, max_files: int = 10): #vers 1
        self.max_files = max_files
        self.recent_files = []
        self.settings_file = "recent_files.json"
        self.load_recent_files()
    
    def add_file(self, file_path: str): #vers 1
        """Add file to recent files"""
        if file_path in self.recent_files:
            self.recent_files.remove(file_path)
        
        self.recent_files.insert(0, file_path)
        
        if len(self.recent_files) > self.max_files:
            self.recent_files = self.recent_files[:self.max_files]
        
        self.save_recent_files()

    def get_recent_files(self) -> List[str]: #vers 1
        """Get list of recent files"""
        return self.recent_files.copy()

    def clear_recent_files(self): #vers 1
        """Clear recent files list"""
        self.recent_files.clear()
        self.save_recent_files()

    def load_recent_files(self): #vers 1
        """Load recent files from settings"""
        try:
            with open(self.settings_file, 'r') as f:
                self.recent_files = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            self.recent_files = []

    def save_recent_files(self): #vers 1
        """Save recent files to settings"""
        try:
            with open(self.settings_file, 'w') as f:
                json.dump(self.recent_files, f)
        except Exception as e:
            print(f"Failed to save recent files: {e}")

# COMPLETE UTILITY FUNCTIONS

def format_file_size(size_bytes: int) -> str: #vers 1
    """Format file size in human readable format"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f} MB"

def detect_img_version(file_path: str) -> IMGVersion: #vers 1
    """Detect IMG version from file path and contents"""
    try:
        if not os.path.exists(file_path):
            return IMGVersion.UNKNOWN

        # Check if it's a .dir file (Version 1)
        if file_path.lower().endswith('.dir'):
            img_path = file_path[:-4] + '.img'
            if os.path.exists(img_path):
                return IMGVersion.VERSION_1

        # Check if it's a single .img file (Version 2)
        if file_path.lower().endswith('.img'):
            try:
                with open(file_path, 'rb') as f:
                    header = f.read(4)
                    if header == b'VER2':
                        return IMGVersion.VERSION_2
                    # Could be Version 1 IMG file without DIR
                    return IMGVersion.VERSION_1
            except:
                pass

        return IMGVersion.UNKNOWN
        
    except Exception as e:
        print(f"[ERROR] Error detecting IMG version: {e}")
        return IMGVersion.UNKNOWN

def create_img_file(file_path: str, version: IMGVersion = IMGVersion.VERSION_2) -> Optional[IMGFile]: #vers 1
    """Create and return IMG file instance"""
    try:
        img_file = IMGFile()
        img_file.file_path = file_path
        img_file.version = version
        
        if img_file.open():
            return img_file
        else:
            return None
            
    except Exception as e:
        print(f"[ERROR] Failed to create IMG file: {e}")
        return None

def populate_table_with_sample_data(table: QTableWidget): #vers 1
    """Populate table with sample data for testing"""
    try:
        sample_entries = [
            ("player.dff", "DFF", "2.3 MB", "0x00001000", "3.6.0.3", "0x1803FFFF", "Player model"),
            ("player.txd", "TXD", "512 KB", "0x00245000", "3.6.0.3", "0x1803FFFF", "Player textures"),
            ("vehicle.col", "COL", "128 KB", "0x002C5000", "N/A", "N/A", "Vehicle collision"),
            ("animation.ifp", "IFP", "256 KB", "0x00345000", "3.1.0.1", "0x1003FFFF", "Character animations")
        ]
        
        table.setRowCount(len(sample_entries))
        
        for row, entry_data in enumerate(sample_entries):
            for col, data in enumerate(entry_data):
                item = QTableWidgetItem(str(data))
                table.setItem(row, col, item)
                
        return True
        
    except Exception as e:
        print(f"[ERROR] Failed to populate sample data: {e}")
        return False

def create_entries_table_panel(parent=None) -> QWidget: #vers 1
    """Create complete entries table panel with filters"""
    try:
        panel = QWidget(parent)
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(0, 0, 0, 0)

        # Add filter panel
        filter_panel = FilterPanel()
        layout.addWidget(filter_panel)
        
        # Add entries table
        entries_table = IMGEntriesTable()
        layout.addWidget(entries_table)
        
        # Add info panel
        info_panel = IMGFileInfoPanel()
        layout.addWidget(info_panel)
        
        # Connect filter to table (basic implementation)
        def apply_filters(filters):
            # Basic filter implementation - would need to be expanded
            print(f"Applying filters: {filters}")
        
        filter_panel.filter_changed.connect(apply_filters)
        
        return panel
        
    except Exception as e:
        print(f"[ERROR] Failed to create entries table panel: {e}")
        return QWidget(parent)

def integrate_filtering(main_window) -> bool: #vers 1
    """Integrate filtering functionality into main window"""
    try:
        # Add filter methods to main window
        main_window.filter_entries_by_type = lambda file_type: filter_entries_by_type(main_window, file_type)
        main_window.filter_entries_by_name = lambda name_pattern: filter_entries_by_name(main_window, name_pattern)
        main_window.clear_filters = lambda: clear_all_filters(main_window)
        
        print("✅ Filtering functionality integrated")
        return True
        
    except Exception as e:
        print(f"❌ Failed to integrate filtering: {e}")
        return False

def filter_entries_by_type(main_window, file_type: str) -> bool: #vers 1
    """Filter entries by file type"""
    try:
        if not hasattr(main_window, 'current_img') or not main_window.current_img:
            return False
            
        # Implementation would filter the display table
        print(f"[DEBUG] Filtering entries by type: {file_type}")
        return True
        
    except Exception as e:
        print(f"[ERROR] Failed to filter by type: {e}")
        return False

def filter_entries_by_name(main_window, name_pattern: str) -> bool: #vers 1
    """Filter entries by name pattern"""
    try:
        if not hasattr(main_window, 'current_img') or not main_window.current_img:
            return False
            
        # Implementation would filter the display table
        print(f"[DEBUG] Filtering entries by name: {name_pattern}")
        return True
        
    except Exception as e:
        print(f"[ERROR] Failed to filter by name: {e}")
        return False

def clear_all_filters(main_window) -> bool: #vers 1
    """Clear all applied filters"""
    try:
        # Implementation would clear all filters
        print(f"[DEBUG] Clearing all filters")
        return True
        
    except Exception as e:
        print(f"[ERROR] Failed to clear filters: {e}")
        return False

# COMPATIBILITY FUNCTIONS

def integrate_fixed_add_entry_methods(img_file_class): #vers 1
    """Compatibility function - methods already integrated in clean version"""
    try:
        print("ℹ️  Fixed add_entry methods already integrated in clean version")
        return True
        
    except Exception as e:
        print(f"❌ Failed to integrate methods: {e}")
        return False

def add_save_methods_to_imgfile_class(): #vers 1
    """Compatibility function - methods already integrated in clean version"""
    try:
        print("ℹ️  Save methods already integrated in clean version")
        return True
        
    except Exception as e:
        print(f"❌ Failed to add save methods: {e}")
        return False

# COMPLETE EXPORTS LIST - MAINTAIN 100% COMPATIBILITY

__all__ = [
    # Core classes
    'IMGFile',
    'IMGEntry', 
    'IMGVersion',
    'IMGPlatform',
    'Platform',
    'FileType',
    'CompressionType',
    'ValidationResult',
    
    # GUI classes
    'IMGEntriesTable',
    'FilterPanel', 
    'IMGFileInfoPanel',
    'TabFilterWidget',
    'RecentFilesManager',
    
    # Platform detection functions
    'detect_img_platform',
    'detect_img_platform_inline',
    'get_platform_specific_specs',
    'get_img_platform_info',
    
    # Utility functions
    'format_file_size',
    'detect_img_version',
    'create_img_file',
    'populate_table_with_sample_data',
    'create_entries_table_panel',
    'integrate_filtering',
    'filter_entries_by_type',
    'filter_entries_by_name', 
    'clear_all_filters',
    
    # Compatibility functions
    'integrate_fixed_add_entry_methods',
    'add_save_methods_to_imgfile_class'
]
