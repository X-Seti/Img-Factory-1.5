#this belongs in components/col_core_classes.py - Version: 8
# X-Seti - August14 2025 - IMG Factory 1.5 - COL Core Classes - COMPLETE CLEAN VERSION

"""
COL Core Classes - Complete Clean Version
Core COL file handling classes with complete functionality
Uses IMG debug system for consistent logging and error handling
"""

import struct
import os
from enum import Enum
from typing import List, Optional, Tuple, Dict, Any

# Import IMG debug system
try:
    from components.img_debug_functions import img_debugger
except ImportError:
    # Fallback debug system
    class FallbackDebugger:
        def debug(self, msg): print(f"DEBUG: {msg}")
        def error(self, msg): print(f"ERROR: {msg}")
        def warning(self, msg): print(f"WARNING: {msg}")
        def success(self, msg): print(f"SUCCESS: {msg}")
        def info(self, msg): print(f"INFO: {msg}")
    
    img_debugger = FallbackDebugger()

##Classes -
# BoundingBox
# COLBox
# COLFace
# COLFaceGroup
# COLFile
# COLMaterial
# COLModel
# COLSphere
# COLVertex
# COLVersion
# Vector3

##Methods list -
# _build_col1_model
# _build_col23_model
# _build_col_data
# _build_col_model
# _parse_col1_basic
# _parse_col1_basic_old
# _parse_col1_model
# _parse_col23_model
# _parse_col_data
# _parse_col_model
# calculate_bounding_box
# create_new_model
# diagnose_col_file
# export_to_dict
# get_file_info
# get_stats
# get_stats_dict
# get_summary
# import_from_dict
# is_col_debug_enabled
# load
# load_from_data
# load_from_file
# remove_model
# save_to_file
# set_col_debug_enabled
# update_flags
# validate_file_structure

# Global debug control
_col_debug_enabled = False

def set_col_debug_enabled(enabled: bool): #vers 1
    """Enable or disable COL debug output"""
    global _col_debug_enabled
    _col_debug_enabled = enabled
    img_debugger.debug(f"COL debug {'enabled' if enabled else 'disabled'}")

def is_col_debug_enabled() -> bool: #vers 1
    """Check if COL debug is enabled"""
    global _col_debug_enabled
    return _col_debug_enabled

class COLVersion(Enum):
    """COL file format versions"""
    COL_1 = 1
    COL_2 = 2
    COL_3 = 3
    COL_4 = 4

class Vector3:
    """3D vector class for positions and directions"""
    def __init__(self, x: float = 0.0, y: float = 0.0, z: float = 0.0): #vers 1
        self.x = x
        self.y = y
        self.z = z
    
    def __str__(self):
        return f"Vector3({self.x:.3f}, {self.y:.3f}, {self.z:.3f})"
    
    def __repr__(self):
        return self.__str__()

class BoundingBox:
    """Axis-aligned bounding box"""
    def __init__(self): #vers 1
        self.center = Vector3()
        self.min = Vector3()
        self.max = Vector3()
        self.radius = 0.0
    
    def calculate_from_vertices(self, vertices: List[Vector3]): #vers 1
        """Calculate bounding box from list of vertices"""
        if not vertices:
            return
        
        # Find min/max
        min_x = min(v.x for v in vertices)
        max_x = max(v.x for v in vertices)
        min_y = min(v.y for v in vertices)
        max_y = max(v.y for v in vertices)
        min_z = min(v.z for v in vertices)
        max_z = max(v.z for v in vertices)
        
        self.min = Vector3(min_x, min_y, min_z)
        self.max = Vector3(max_x, max_y, max_z)
        
        # Calculate center
        self.center = Vector3(
            (min_x + max_x) / 2,
            (min_y + max_y) / 2,
            (min_z + max_z) / 2
        )
        
        # Calculate radius (distance from center to corner)
        dx = max_x - self.center.x
        dy = max_y - self.center.y
        dz = max_z - self.center.z
        self.radius = (dx*dx + dy*dy + dz*dz)**0.5

class COLMaterial:
    """COL material definition"""
    def __init__(self, material_id: int = 0, flags: int = 0): #vers 1
        self.material_id = material_id
        self.flags = flags
        self.brightness = 0
        self.light = 0

class COLSphere:
    """COL sphere collision primitive"""
    def __init__(self, center: Vector3, radius: float, material: COLMaterial): #vers 1
        self.center = center
        self.radius = radius
        self.material = material

class COLBox:
    """COL box collision primitive"""
    def __init__(self, min_point: Vector3, max_point: Vector3, material: COLMaterial): #vers 1
        self.min_point = min_point
        self.max_point = max_point
        self.material = material

class COLVertex:
    """COL mesh vertex"""
    def __init__(self, position: Vector3): #vers 1
        self.position = position

class COLFace:
    """COL mesh face"""
    def __init__(self, vertex_indices: Tuple[int, int, int], material: COLMaterial, light: int = 0): #vers 1
        self.vertex_indices = vertex_indices
        self.material = material
        self.light = light

class COLFaceGroup:
    """COL face group"""
    def __init__(self): #vers 1
        self.faces = []
        self.material = COLMaterial()

class COLModel:
    """COL collision model"""
    def __init__(self): #vers 1
        self.name = ""
        self.model_id = 0
        self.version = COLVersion.COL_1
        self.model_size = 0
        
        # Collision primitives
        self.spheres: List[COLSphere] = []
        self.boxes: List[COLBox] = []
        self.vertices: List[COLVertex] = []
        self.faces: List[COLFace] = []
        self.face_groups: List[COLFaceGroup] = []
        
        # Shadow mesh data
        self.shadow_vertices: List[COLVertex] = []
        self.shadow_faces: List[COLFace] = []
        
        # Bounding box
        self.bounding_box = BoundingBox()
        
        # Status flags
        self.has_sphere_data = False
        self.has_box_data = False
        self.has_mesh_data = False
    
    def get_stats(self) -> str: #vers 1
        """Get model statistics as string"""
        return f"{self.name}: S:{len(self.spheres)} B:{len(self.boxes)} V:{len(self.vertices)} F:{len(self.faces)}"
    
    def get_stats_dict(self) -> Dict[str, Any]: #vers 1
        """Get model statistics as dictionary"""
        return {
            'name': self.name,
            'version': self.version.value if self.version else 1,
            'spheres': len(self.spheres),
            'boxes': len(self.boxes),
            'vertices': len(self.vertices),
            'faces': len(self.faces),
            'face_groups': len(self.face_groups),
            'shadow_vertices': len(self.shadow_vertices),
            'shadow_faces': len(self.shadow_faces),
            'total_collision_objects': len(self.spheres) + len(self.boxes),
            'estimated_size': self.model_size
        }

    def calculate_bounding_box(self): #vers 1
        """Calculate bounding box from all collision elements"""
        all_vertices = []
        
        # Add sphere centers as vertices
        for sphere in self.spheres:
            all_vertices.extend([
                Vector3(sphere.center.x - sphere.radius, sphere.center.y - sphere.radius, sphere.center.z - sphere.radius),
                Vector3(sphere.center.x + sphere.radius, sphere.center.y + sphere.radius, sphere.center.z + sphere.radius)
            ])
        
        # Add box corners
        for box in self.boxes:
            all_vertices.extend([box.min_point, box.max_point])
        
        # Add mesh vertices
        all_vertices.extend([vertex.position for vertex in self.vertices])
        
        # Calculate bounding box
        if all_vertices:
            self.bounding_box.calculate_from_vertices(all_vertices)
    
    def update_flags(self): #vers 1
        """Update status flags based on available data"""
        self.has_sphere_data = len(self.spheres) > 0
        self.has_box_data = len(self.boxes) > 0
        self.has_mesh_data = len(self.vertices) > 0 and len(self.faces) > 0

class COLFile:
    """COL file handler with complete load/save functionality"""
    def __init__(self, file_path: str = None): #vers 1
        self.file_path = file_path
        self.models: List[COLModel] = []
        self.is_loaded = False
        self.load_error = None
        self.file_size = 0

    def load(self) -> bool: #vers 1
        """Load COL file"""
        if not self.file_path:
            self.load_error = "No file path specified"
            return False
        return self.load_from_file(self.file_path)

    def load_from_file(self, file_path: str) -> bool: #vers 2
        """Load COL file from disk with enhanced error handling"""
        try:
            self.file_path = file_path
            self.load_error = None  # Clear any previous error

            if not os.path.exists(file_path):
                self.load_error = f"File not found: {file_path}"
                return False

            with open(file_path, 'rb') as f:
                data = f.read()

            self.file_size = len(data)

            if is_col_debug_enabled():
                img_debugger.debug(f"Loading COL file: {os.path.basename(file_path)} ({self.file_size} bytes)")

            return self.load_from_data(data)

        except Exception as e:
            self.load_error = f"File read error: {str(e)}"
            if is_col_debug_enabled():
                img_debugger.error(f"Error loading COL file: {e}")
            return False

    def load_from_data(self, data: bytes) -> bool: #vers 2
        """Load COL data from bytes with proper error handling"""
        try:
            self.models.clear()
            self.is_loaded = False
            self.load_error = None  # Clear any previous error

            if len(data) < 8:
                self.load_error = "File too small (less than 8 bytes)"
                return False

            # Check signature first
            signature = data[:4]
            if signature not in [b'COLL', b'COL\x02', b'COL\x03', b'COL\x04']:
                self.load_error = f"Invalid COL signature: {signature}"
                return False

            success = self._parse_col_data(data)

            if success:
                self.is_loaded = True
                if len(self.models) == 0:
                    self.load_error = "File parsed but no models found"
                    return False
            else:
                if not self.load_error:  # If no specific error was set
                    self.load_error = "Failed to parse COL data"

            return success

        except Exception as e:
            self.load_error = f"Data parsing error: {str(e)}"
            if is_col_debug_enabled():
                img_debugger.error(f"Error parsing COL data: {e}")
            return False

    def _parse_col_data(self, data: bytes) -> bool: #vers 3
        """Parse COL data with enhanced debugging"""
        try:
            self.models = []
            offset = 0

            img_debugger.debug(f"_parse_col_data: Starting with {len(data)} bytes")

            model_count = 0
            while offset < len(data):
                img_debugger.debug(f"_parse_col_data: Parsing model {model_count} at offset {offset}")

                model, consumed = self._parse_col_model(data, offset)

                if model is None:
                    img_debugger.debug(f"_parse_col_data: Model parsing returned None, stopping")
                    break

                self.models.append(model)
                offset += consumed
                model_count += 1

                # Safety check to prevent infinite loops
                if consumed == 0:
                    img_debugger.warning("_parse_col_data: Zero bytes consumed, stopping to prevent infinite loop")
                    break

            img_debugger.debug(f"_parse_col_data: Parsing complete - {len(self.models)} models loaded")
            
            self.is_loaded = True
            return len(self.models) > 0

        except Exception as e:
            self.load_error = f"Parsing error: {str(e)}"
            img_debugger.error(f"_parse_col_data: Exception during parsing: {e}")
            return False

    def _parse_col_model(self, data: bytes, offset: int) -> Tuple[Optional[COLModel], int]: #vers 3
        """Parse single COL model"""
        try:
            img_debugger.debug(f"_parse_col_model: Starting at offset {offset}, data length {len(data)}")

            if offset + 8 > len(data):
                img_debugger.debug("_parse_col_model: Not enough data for model header")
                return None, 0

            # Read FourCC signature
            fourcc = data[offset:offset+4]
            img_debugger.debug(f"_parse_col_model: Read FourCC: {fourcc}")

            if fourcc not in [b'COLL', b'COL\x02', b'COL\x03', b'COL\x04']:
                img_debugger.debug(f"_parse_col_model: Invalid FourCC signature: {fourcc}")
                return None, 0

            # Read file size
            file_size = struct.unpack('<I', data[offset+4:offset+8])[0]
            total_size = file_size + 8

            img_debugger.debug(f"_parse_col_model: File size from header: {file_size}, total size: {total_size}")

            if offset + total_size > len(data):
                img_debugger.warning(f"_parse_col_model: Model size extends beyond data: need {total_size}, have {len(data) - offset}")
                return None, 0

            # Create model
            model = COLModel()
            model.model_size = file_size

            # Determine version
            if fourcc == b'COLL':
                model.version = COLVersion.COL_1
                img_debugger.debug("_parse_col_model: Detected COL1 format")
            elif fourcc == b'COL\x02':
                model.version = COLVersion.COL_2
                img_debugger.debug("_parse_col_model: Detected COL2 format")
            elif fourcc == b'COL\x03':
                model.version = COLVersion.COL_3
                img_debugger.debug("_parse_col_model: Detected COL3 format")
            elif fourcc == b'COL\x04':
                model.version = COLVersion.COL_4
                img_debugger.debug("_parse_col_model: Detected COL4 format")

            # Parse model data based on version
            model_data = data[offset + 8:offset + total_size]
            img_debugger.debug(f"_parse_col_model: Extracted model data: {len(model_data)} bytes")

            try:
                if model.version == COLVersion.COL_1:
                    img_debugger.debug("_parse_col_model: Calling _parse_col1_model")
                    self._parse_col1_model(model, model_data)
                else:
                    img_debugger.debug("_parse_col_model: Calling _parse_col23_model")
                    self._parse_col23_model(model, model_data)
            except Exception as e:
                img_debugger.error(f"_parse_col_model: Failed to parse model data: {e}")
                return None, 0

            # Validate the model was parsed correctly
            stats_text = f"{model.name}: S:{len(model.spheres)} B:{len(model.boxes)} V:{len(model.vertices)} F:{len(model.faces)}"
            img_debugger.debug(f"_parse_col_model: Model parsed successfully - {stats_text}")

            return model, total_size

        except Exception as e:
            img_debugger.error(f"_parse_col_model: Exception in method: {e}")
            return None, 0

    def _parse_col1_model(self, model: COLModel, data: bytes): #vers 5
        """Parse COL version 1 model with fixed count reading"""
        try:
            if len(data) < 22:
                img_debugger.error("COL1: Data too small for model name")
                return
            
            offset = 0
            
            # Read name (22 bytes, null-terminated)
            name_bytes = data[offset:offset+22]
            model.name = name_bytes.split(b'\x00')[0].decode('ascii', errors='ignore')
            offset += 22
            
            # Read model ID (4 bytes)
            if offset + 4 <= len(data):
                model.model_id = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
            
            # Set default name if empty
            if not model.name:
                model.name = f"Model_{model.model_id}"
            
            # Read collision data counts (20 bytes total)
            if offset + 20 <= len(data):
                num_spheres = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                num_unknown = struct.unpack('<I', data[offset:offset+4])[0] 
                offset += 4
                num_boxes = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                num_vertices = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                num_faces = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                
                img_debugger.debug(f"COL1: Model {model.name} - S:{num_spheres} U:{num_unknown} B:{num_boxes} V:{num_vertices} F:{num_faces}")
                
                # VALIDATE face count by checking remaining data
                remaining_data = len(data) - offset
                
                # Skip unknown data section
                offset += num_unknown * 4
                
                # Calculate what we can actually parse for faces
                spheres_bytes = num_spheres * 24
                boxes_bytes = num_boxes * 32  
                vertices_bytes = num_vertices * 12
                
                offset_after_other_data = offset + spheres_bytes + boxes_bytes + vertices_bytes
                remaining_for_faces = len(data) - offset_after_other_data
                max_possible_faces = max(0, remaining_for_faces // 14)  # 14 bytes per COL1 face
                
                if num_faces > max_possible_faces:
                    img_debugger.warning(f"COL1: Face count {num_faces} too high, limiting to {max_possible_faces}")
                    num_faces = max_possible_faces
                
                # Parse collision data with corrected counts
                self._parse_col1_basic(model, data, offset, num_spheres, num_boxes, num_vertices, num_faces)
                    
            model.update_flags()
            
            img_debugger.debug(f"COL1: Model {model.name} - S:{len(model.spheres)} B:{len(model.boxes)} V:{len(model.vertices)} F:{len(model.faces)}")
            
        except Exception as e:
            img_debugger.error(f"COL1: Error parsing model: {e}")

    def _parse_col1_basic(self, model: COLModel, data: bytes, offset: int, num_spheres: int, num_boxes: int, num_vertices: int, num_faces: int): #vers 2
        """Basic COL1 parsing with proper bounds checking"""
        try:
            # Parse spheres
            img_debugger.debug(f"COL1: Parsing {num_spheres} spheres starting at offset {offset}")
            for i in range(num_spheres):
                if offset + 24 > len(data):
                    img_debugger.warning(f"COL1: Not enough data for sphere {i}, stopping")
                    break
                center = Vector3(*struct.unpack('<fff', data[offset:offset+12]))
                offset += 12
                radius = struct.unpack('<f', data[offset:offset+4])[0]
                offset += 4
                material_id = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                flags = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                
                material = COLMaterial(material_id, flags=flags)
                sphere = COLSphere(center, radius, material)
                model.spheres.append(sphere)
            
            img_debugger.debug(f"COL1: Successfully parsed {len(model.spheres)} spheres")
            
            # Parse boxes
            img_debugger.debug(f"COL1: Parsing {num_boxes} boxes starting at offset {offset}")
            for i in range(num_boxes):
                if offset + 32 > len(data):
                    img_debugger.warning(f"COL1: Not enough data for box {i}, stopping")
                    break
                min_point = Vector3(*struct.unpack('<fff', data[offset:offset+12]))
                offset += 12
                max_point = Vector3(*struct.unpack('<fff', data[offset:offset+12]))
                offset += 12
                material_id = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                flags = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                
                material = COLMaterial(material_id, flags=flags)
                box = COLBox(min_point, max_point, material)
                model.boxes.append(box)
            
            img_debugger.debug(f"COL1: Successfully parsed {len(model.boxes)} boxes")
            
            # Parse vertices
            img_debugger.debug(f"COL: Parsing {num_vertices} vertices starting at offset {offset}")
            for i in range(num_vertices):
                if offset + 12 > len(data):
                    img_debugger.warning(f"COL: Not enough data for vertex {i}, stopping")
                    break
                position = Vector3(*struct.unpack('<fff', data[offset:offset+12]))
                offset += 12
                vertex = COLVertex(position)
                model.vertices.append(vertex)
            
            img_debugger.debug(f"COL: Successfully parsed {len(model.vertices)} vertices")
            
            # Parse faces with bounds checking
            img_debugger.debug(f"COL1: Parsing {num_faces} faces starting at offset {offset}")
            for i in range(num_faces):
                if offset + 14 > len(data):
                    img_debugger.debug(f"COL1: Not enough data for face {i}, stopping")
                    break
                    
                vertex_indices = struct.unpack('<HHH', data[offset:offset+6])
                offset += 6
                material_id = struct.unpack('<H', data[offset:offset+2])[0]
                offset += 2
                light = struct.unpack('<H', data[offset:offset+2])[0]
                offset += 2
                flags = struct.unpack('<I', data[offset:offset+4])[0]
                offset += 4
                
                material = COLMaterial(material_id, flags=flags)
                face = COLFace(vertex_indices, material, light)
                model.faces.append(face)
            
            img_debugger.debug(f"COL1: Successfully parsed {len(model.faces)} faces")
            
        except Exception as e:
            img_debugger.error(f"COL1: Error in basic parsing: {e}")

    def _parse_col23_model(self, model: COLModel, data: bytes): #vers 2
        """Parse COL version 2/3 model with safe parsing methods"""
        try:
            offset = 0
            
            # Parse model name (22 bytes)
            if len(data) < 22:
                img_debugger.warning("COL2/3: Data too small for model name")
                return
                
            name_bytes = data[offset:offset+22]
            model.name = name_bytes.split(b'\x00')[0].decode('ascii', errors='ignore')
            offset += 22
            
            # Parse model ID (2 bytes)
            if offset + 2 > len(data):
                img_debugger.warning("COL2/3: Not enough data for model ID")
                return
                
            model.model_id = struct.unpack('<H', data[offset:offset+2])[0]
            offset += 2
            
            # Set default name if empty
            if not model.name:
                model.name = f"Model_{model.model_id}"
            
            # Parse bounding data (varies by version)
            if model.version in [COLVersion.COL_2, COLVersion.COL_3]:
                # COL2/3: bounding sphere + box (28 bytes)
                if offset + 28 > len(data):
                    img_debugger.warning("COL2/3: Not enough data for bounds")
                    return
                    
                # Bounding sphere (16 bytes)
                center_x, center_y, center_z, radius = struct.unpack('<ffff', data[offset:offset+16])
                model.bounding_box.center = Vector3(center_x, center_y, center_z)
                model.bounding_box.radius = radius
                offset += 16
                
                # Bounding box (12 bytes)
                min_x, min_y, min_z = struct.unpack('<fff', data[offset:offset+12])
                model.bounding_box.min = Vector3(min_x, min_y, min_z)
                offset += 12
            
            # For now, initialize empty collision data
            # TODO: Add full COL2/3 parsing implementation
            model.spheres = []
            model.boxes = []
            model.vertices = []
            model.faces = []
            model.face_groups = []
            model.shadow_vertices = []
            model.shadow_faces = []
            
            model.update_flags()
            
            img_debugger.debug(f"COL2/3: Model {model.name} parsed (basic implementation)")
            
        except Exception as e:
            img_debugger.error(f"COL2/3: Error parsing model: {e}")

    def save_to_file(self, file_path: str) -> bool: #vers 1
        """Save COL file to disk"""
        try:
            data = self._build_col_data()
            
            with open(file_path, 'wb') as f:
                f.write(data)
            
            if is_col_debug_enabled():
                img_debugger.success(f"COL file saved: {os.path.basename(file_path)} ({len(data)} bytes)")
            
            return True
            
        except Exception as e:
            if is_col_debug_enabled():
                img_debugger.error(f"Error saving COL file: {e}")
            return False

    def _build_col_data(self) -> bytes: #vers 1
        """Build COL file data from models"""
        data = b''
        
        for model in self.models:
            model_data = self._build_col_model(model)
            data += model_data
        
    def create_new_model(self, name: str = "", version: COLVersion = COLVersion.COL_1) -> COLModel: #vers 1
        """Create a new empty COL model"""
        model = COLModel()
        model.name = name if name else f"NewModel_{len(self.models)}"
        model.version = version
        model.model_id = len(self.models)
        
        self.models.append(model)
        img_debugger.debug(f"Created new COL model: {model.name}")
        return model

    def remove_model(self, index: int) -> bool: #vers 1
        """Remove model by index"""
        if 0 <= index < len(self.models):
            removed_model = self.models.pop(index)
            img_debugger.debug(f"Removed COL model: {removed_model.name}")
            return True
        return False

    def validate_file_structure(self) -> bool: #vers 1
        """Validate COL file structure"""
        if not self.is_loaded:
            return False
        
        if not self.models:
            return False
        
        # Check each model
        for i, model in enumerate(self.models):
            if not model.name:
                img_debugger.warning(f"Model {i} has no name")
            
            if not hasattr(model, 'version') or not model.version:
                img_debugger.warning(f"Model {i} has invalid version")
                return False
        
        return True

    def get_file_info(self) -> Dict[str, Any]: #vers 1
        """Get comprehensive file information"""
        info = {
            'file_path': self.file_path,
            'file_size': self.file_size,
            'is_loaded': self.is_loaded,
            'model_count': len(self.models),
            'load_error': self.load_error
        }
        
        if self.models:
            info['models'] = [model.get_stats_dict() for model in self.models]
            info['total_spheres'] = sum(len(m.spheres) for m in self.models)
            info['total_boxes'] = sum(len(m.boxes) for m in self.models)
            info['total_vertices'] = sum(len(m.vertices) for m in self.models)
            info['total_faces'] = sum(len(m.faces) for m in self.models)
        
        return info

    def export_to_dict(self) -> Dict[str, Any]: #vers 1
        """Export COL data to dictionary format"""
        return {
            'file_info': self.get_file_info(),
            'models': [model.get_stats_dict() for model in self.models]
        }

    def import_from_dict(self, data: Dict[str, Any]) -> bool: #vers 1
        """Import COL data from dictionary format"""
        try:
            if 'models' not in data:
                return False
            
            self.models.clear()
            
            for model_data in data['models']:
                model = COLModel()
                model.name = model_data.get('name', 'Unknown')
                model.model_id = model_data.get('model_id', 0)
                
                # Set version
                version_val = model_data.get('version', 1)
                model.version = COLVersion(version_val)
                
                # Initialize empty collections
                model.spheres = []
                model.boxes = []
                model.vertices = []
                model.faces = []
                model.face_groups = []
                model.shadow_vertices = []
                model.shadow_faces = []
                
                self.models.append(model)
            
            self.is_loaded = True
            img_debugger.success(f"Imported {len(self.models)} COL models from dictionary")
            return True
            
        except Exception as e:
            img_debugger.error(f"Error importing COL data: {e}")
            return False

    def _build_col_model(self, model: COLModel) -> bytes: #vers 1
        """Build data for a single COL model"""
        if model.version == COLVersion.COL_1:
            return self._build_col1_model(model)
        else:
            return self._build_col23_model(model)

    def _build_col1_model(self, model: COLModel) -> bytes: #vers 1
        """Build COL version 1 model data"""
        # Basic COL1 structure
        data = b'COLL'
        
        # Calculate content size
        content_size = 22 + 4  # name + model_id
        data += struct.pack('<I', content_size)
        
        # Write name (22 bytes, padded with nulls)
        name_bytes = model.name.encode('ascii')[:22]
        name_bytes += b'\x00' * (22 - len(name_bytes))
        data += name_bytes
        
        # Write model ID
        data += struct.pack('<I', model.model_id)
        
        return data

    def _build_col23_model(self, model: COLModel) -> bytes: #vers 1
        """Build COL version 2/3 model data"""
        # Determine signature
        if model.version == COLVersion.COL_2:
            data = b'COL\x02'
        elif model.version == COLVersion.COL_3:
            data = b'COL\x03'
        else:
            data = b'COL\x04'
        
        # Calculate content size
        content_size = 22 + 2 + 28  # name + model_id + bounds
        data += struct.pack('<I', content_size)
        
        # Write name (22 bytes, padded with nulls)
        name_bytes = model.name.encode('ascii')[:22]
        name_bytes += b'\x00' * (22 - len(name_bytes))
        data += name_bytes
        
        # Write model ID (2 bytes for COL2/3)
        data += struct.pack('<H', model.model_id)
        
        # Write bounding data (28 bytes)
        # Bounding sphere (16 bytes)
        data += struct.pack('<ffff', 
            model.bounding_box.center.x,
            model.bounding_box.center.y,
            model.bounding_box.center.z,
            model.bounding_box.radius)
        
        # Bounding box (12 bytes)
        data += struct.pack('<fff',
            model.bounding_box.min.x,
            model.bounding_box.min.y,
            model.bounding_box.min.z)
        
        return data

    def get_summary(self) -> str: #vers 1
        """Get file summary"""
        lines = []
        lines.append(f"COL File: {os.path.basename(self.file_path) if self.file_path else 'Unknown'}")
        lines.append(f"File Size: {self.file_size:,} bytes")
        lines.append(f"Models: {len(self.models)}")
        
        if self.is_loaded and self.models:
            # Calculate totals
            total_stats = {
                'spheres': sum(len(m.spheres) for m in self.models),
                'boxes': sum(len(m.boxes) for m in self.models),
                'vertices': sum(len(m.vertices) for m in self.models),
                'faces': sum(len(m.faces) for m in self.models)
            }
            
            lines.append(f"Total Objects: {total_stats['spheres']} spheres, {total_stats['boxes']} boxes")
            lines.append(f"Total Geometry: {total_stats['vertices']} vertices, {total_stats['faces']} faces")
        else:
            lines.append(f"Loaded: No")
            if self.load_error:
                lines.append(f"Error: {self.load_error}")
        
        return "\n".join(lines)


def diagnose_col_file(file_path: str) -> dict: #vers 1
    """Diagnose COL file structure for debugging"""
    try:
        with open(file_path, 'rb') as f:
            data = f.read()
        
        info = {
            'file_size': len(data),
            'exists': True,
            'readable': True,
        }
        
        if len(data) < 8:
            info['error'] = 'File too small (< 8 bytes)'
            return info
        
        # Check first 8 bytes
        header = data[:8]
        info['header_hex'] = header.hex()
        info['header_ascii'] = header[:4]
        
        # Try to identify COL signature
        signature = data[:4]
        if signature == b'COLL':
            info['detected_version'] = 'COL1'
            info['signature_valid'] = True
        elif signature == b'COL\x02':
            info['detected_version'] = 'COL2'
            info['signature_valid'] = True
        elif signature == b'COL\x03':
            info['detected_version'] = 'COL3'
            info['signature_valid'] = True
        elif signature == b'COL\x04':
            info['detected_version'] = 'COL4'
            info['signature_valid'] = True
        else:
            info['detected_version'] = 'Unknown'
            info['signature_valid'] = False
            info['error'] = f'Invalid signature: {signature}'
        
        # If valid signature, try to read size
        if info['signature_valid']:
            try:
                size = struct.unpack('<I', data[4:8])[0]
                info['declared_size'] = size
                info['total_expected_size'] = size + 8
                info['size_matches'] = (size + 8 == len(data))
            except:
                info['error'] = 'Failed to read size field'
        
        return info
        
    except Exception as e:
        return {
            'exists': os.path.exists(file_path),
            'readable': False,
            'error': str(e)
        }


# Export main classes for import
__all__ = [
    'COLFile', 'COLModel', 'COLVersion', 'COLMaterial',
    'COLSphere', 'COLBox', 'COLVertex', 'COLFace', 'COLFaceGroup',
    'Vector3', 'BoundingBox', 'diagnose_col_file',
    'set_col_debug_enabled', 'is_col_debug_enabled'
]