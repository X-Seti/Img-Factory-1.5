#this belongs in core/export.py - Version: 1
# X-Seti - Aug15 2025 - IMG Factory 1.5 - Main Export Functions

"""
Main Export Functions - Standard export with full options dialog
Provides comprehensive export functionality with user configuration
"""

from PyQt6.QtWidgets import QMessageBox, QProgressDialog
from PyQt6.QtCore import Qt
from methods.export_shared import (
    ExportThread, get_selected_entries, get_export_folder, validate_export_entries
)

##Methods list -
# export_all_function
# export_selected_function

def export_selected_function(main_window): #vers 1
    """Export selected entries with full options dialog"""
    try:
        if not hasattr(main_window, 'current_img') or not main_window.current_img:
            QMessageBox.warning(main_window, "No IMG File", "Please open an IMG file first")
            return
        
        # Get selected entries
        selected_entries = get_selected_entries(main_window)
        if not validate_export_entries(selected_entries, main_window):
            return
        
        if hasattr(main_window, 'log_message'):
            main_window.log_message(f"üì§ Preparing to export {len(selected_entries)} selected entries")
        
        # Show export options dialog with Assists folder integration
        try:
            from core.dialogs import ExportOptionsDialog
            options_dialog = ExportOptionsDialog(main_window, len(selected_entries))
            
            if options_dialog.exec() != options_dialog.DialogCode.Accepted:
                return
            
            export_options = options_dialog.get_options()
            export_folder = export_options.get('export_folder')
            
            if not export_folder:
                QMessageBox.warning(main_window, "No Folder", "Please select an export folder")
                return
                
        except ImportError:
            # Fallback - get folder directly
            export_folder = get_export_folder(main_window, "Select Export Destination")
            if not export_folder:
                return
            export_options = {
                'organize_by_type': True,
                'overwrite': True,
                'create_log': False
            }
            if hasattr(main_window, 'log_message'):
                main_window.log_message("‚ÑπÔ∏è Using default export options")
        
        # Start export
        _start_export_with_progress(main_window, selected_entries, export_folder, export_options)
        
    except Exception as e:
        if hasattr(main_window, 'log_message'):
            main_window.log_message(f"‚ùå Export selected error: {str(e)}")
        QMessageBox.critical(main_window, "Export Error", f"Export failed: {str(e)}")

def export_all_function(main_window): #vers 1
    """Export all entries with options dialog"""
    try:
        if not hasattr(main_window, 'current_img') or not main_window.current_img:
            QMessageBox.warning(main_window, "No IMG File", "Please open an IMG file first")
            return
        
        all_entries = main_window.current_img.entries
        if not validate_export_entries(all_entries, main_window):
            return
        
        if hasattr(main_window, 'log_message'):
            main_window.log_message(f"üì§ Preparing to export all {len(all_entries)} entries")
        
        # Confirm export all
        reply = QMessageBox.question(
            main_window, 
            "Export All Entries",
            f"Export all {len(all_entries)} entries from this IMG file?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # Show export options dialog
        try:
            from core.dialogs import ExportOptionsDialog
            options_dialog = ExportOptionsDialog(main_window, len(all_entries))
            
            if options_dialog.exec() != options_dialog.DialogCode.Accepted:
                return
            
            export_options = options_dialog.get_options()
            export_folder = export_options.get('export_folder')
            
            if not export_folder:
                QMessageBox.warning(main_window, "No Folder", "Please select an export folder")
                return
                
        except ImportError:
            # Fallback to basic folder selection
            export_folder = get_export_folder(main_window, "Select Export Destination for All Entries")
            if not export_folder:
                return
            export_options = {
                'organize_by_type': True,
                'overwrite': False,  # More conservative for large exports
                'create_log': True
            }
            if hasattr(main_window, 'log_message'):
                main_window.log_message("‚ÑπÔ∏è Using default export options")
        
        # Start export
        _start_export_with_progress(main_window, all_entries, export_folder, export_options)
        
    except Exception as e:
        if hasattr(main_window, 'log_message'):
            main_window.log_message(f"‚ùå Export all error: {str(e)}")
        QMessageBox.critical(main_window, "Export All Error", f"Export all failed: {str(e)}")

def _start_export_with_progress(main_window, entries, export_folder, export_options): #vers 3
    """Start export with progress dialog - FIXED threading cleanup"""
    export_thread = None
    progress_dialog = None
    
    try:
        # Create export thread
        export_thread = ExportThread(main_window, entries, export_folder, export_options)
        
        # Create progress dialog
        progress_dialog = QProgressDialog("Export in progress...", "Cancel", 0, 100, main_window)
        progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
        progress_dialog.setMinimumDuration(0)
        progress_dialog.setAutoClose(True)  # CRITICAL: Auto close to prevent hanging
        progress_dialog.setAutoReset(True)  # CRITICAL: Auto reset to prevent hanging
        
        def cleanup_thread():
            """Cleanup thread properly"""
            try:
                if export_thread and export_thread.isRunning():
                    export_thread.stop_export()
            except Exception:
                pass
        
        def update_progress(progress, message):
            try:
                if progress_dialog and not progress_dialog.wasCanceled():
                    progress_dialog.setValue(progress)
                    progress_dialog.setLabelText(message)
            except Exception:
                pass  # Don't let progress updates crash export
            
        def export_finished(success, message, stats):
            try:
                # CRITICAL: Cleanup thread first
                cleanup_thread()
                
                # CRITICAL: Close progress dialog
                if progress_dialog:
                    progress_dialog.close()
                    progress_dialog.deleteLater()
                
                # Show result dialog
                if success:
                    QMessageBox.information(main_window, "Export Complete", message)
                    if hasattr(main_window, 'log_message'):
                        main_window.log_message(f"‚úÖ {message}")
                else:
                    QMessageBox.critical(main_window, "Export Failed", message)
                    if hasattr(main_window, 'log_message'):
                        main_window.log_message(f"‚ùå {message}")
                        
            except Exception as e:
                if hasattr(main_window, 'log_message'):
                    main_window.log_message(f"‚ùå Error in export completion: {e}")
        
        def handle_cancel():
            try:
                cleanup_thread()
                if hasattr(main_window, 'log_message'):
                    main_window.log_message("üö´ Export cancelled by user")
            except Exception:
                pass  # Don't crash on cancel
        
        # CRITICAL: Connect signals with proper error handling
        try:
            export_thread.progress_updated.connect(update_progress)
            export_thread.export_completed.connect(export_finished)
            progress_dialog.canceled.connect(handle_cancel)
            
            # CRITICAL: Cleanup on main window close
            if hasattr(main_window, 'closeEvent'):
                original_close = main_window.closeEvent
                def safe_close_event(event):
                    cleanup_thread()
                    original_close(event)
                main_window.closeEvent = safe_close_event
                
        except Exception as e:
            QMessageBox.critical(main_window, "Setup Error", f"Failed to setup export operation: {str(e)}")
            cleanup_thread()
            return
        
        # Start export
        export_thread.start()
        progress_dialog.show()
        
    except Exception as e:
        # CRITICAL: Cleanup on any error
        if export_thread:
            try:
                export_thread.stop_export()
            except:
                pass
        if progress_dialog:
            try:
                progress_dialog.close()
                progress_dialog.deleteLater()
            except:
                pass
                
        if hasattr(main_window, 'log_message'):
            main_window.log_message(f"‚ùå Export thread error: {str(e)}")
        QMessageBox.critical(main_window, "Export Error", f"Failed to start export: {str(e)}")

__all__ = [
    'export_selected_function',
    'export_all_function'
]